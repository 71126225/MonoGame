<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
Func<string, bool, string> GetCsType = (ctype, isargument) =>
{
    var isPtr = false;
    var realType = ctype;
    var isKnownType = false;

    if (ctype.Contains("*"))
    {
        isPtr = true;
        realType = realType.Replace("*", "");
    }

    if (realType.StartsWith("mg") || realType.StartsWith("MG"))
    {
        isKnownType = true;
        realType = realType.Substring(2);
    }

    if (isPtr)
    {
        if (isargument)
        {
            if (isKnownType)
            {
                return "ref " + realType;
            }
            else
            {
                return "IntPtr";
            }
        }
        else
        {
            return "IntPtr";
        }
    }
    else
    {
        return realType;
    }
};

#>
// MonoGame - Copyright (C) The MonoGame Team
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

// This code is generated by a .tt template, don't modify it by hand.

using System;
using System.Runtime.InteropServices;
using System.Security;
using Microsoft.Xna.Framework;

namespace MonoGame.Framework
{
    static class MGNative
    {
        public const string Library = "/Users/harry/GitHub/MonoGame/MGNative/builddir/libmonogame.dylib";
        
        public static unsafe string GetString(IntPtr hglobal)
        {
            if (hglobal == IntPtr.Zero)
                return string.Empty;

            var ptr = (byte*)hglobal;
            while (*ptr != 0)
                ptr++;

            var ret = System.Text.Encoding.UTF8.GetString((byte*)hglobal, (int)(ptr - (byte*)hglobal));
            Marshal.FreeHGlobal(hglobal);
            
            return ret;
        }
<#
var includePath = "/Users/harry/GitHub/MonoGame/MGNative/include";
var regExp = @"MG_EXPORT +(?<ReturnValue>[^ ]+) +(?<Method>[^ ]+) +\((?<Arguments>.*)\);";
var regex = new Regex(regExp);

foreach (var file in Directory.GetFiles(includePath))
{
    foreach (var line in File.ReadAllLines(file))
    {
        var match = regex.Match(line);

        if (match.Success)
        {
            var method = match.Groups["Method"].ToString();
            var returnType = match.Groups["ReturnValue"].ToString();
            var arguments = match.Groups["Arguments"].ToString().Split(',');

            var trimmedMethod = method.ToString();
            if (trimmedMethod.StartsWith("MG_"))
                trimmedMethod = trimmedMethod.Substring(3);

            var formattedArguments = string.Empty;
            var formattedArgumentsWithoutType = string.Empty;
            foreach (var arg in arguments)
            {
                var split = arg.Split(new[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                if (split.Length != 2)
                    continue;

                if (formattedArguments.Length > 0)
                {
                    formattedArguments += ", ";
                    formattedArgumentsWithoutType += ", ";
                }

                formattedArguments += GetCsType(split[0], true) + " " + split[1];
                formattedArgumentsWithoutType += split[1];
            }
            
            var returnArgs = "public static extern " + GetCsType(returnType, false) + " ";
            
            if (returnType == "mgstring")
            {
                returnArgs = "private static extern IntPtr MG_";
#>

        public static string <#=trimmedMethod#>(<#=formattedArguments#>)
        {
            return GetString(MG_<#=trimmedMethod#>(<#=formattedArgumentsWithoutType#>));
        }
<#
            }
#>

        [DllImport(Library, EntryPoint = "<#=method#>", CharSet = CharSet.Ansi), SuppressUnmanagedCodeSecurity]
        <#=GetCsType(returnArgs, false)#><#=trimmedMethod#>(<#=formattedArguments#>);
<#
        }
    }
}
#>
    }
}
